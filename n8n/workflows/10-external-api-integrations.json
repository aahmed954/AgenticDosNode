{
  "name": "External API Integrations - Weather, News & Third-Party Services",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "value": "0 8 * * 1-5"
            }
          ]
        }
      },
      "id": "morning-data-fetch",
      "name": "Morning Data Fetch",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [
        260,
        300
      ]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://api.openweathermap.org/data/2.5/weather?q=New York,US&appid={{ $env.WEATHER_API_KEY }}&units=metric",
        "options": {}
      },
      "id": "fetch-weather-data",
      "name": "Fetch Weather Data",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        480,
        200
      ]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum&vs_currencies=usd&include_24hr_change=true",
        "options": {}
      },
      "id": "fetch-crypto-prices",
      "name": "Fetch Crypto Prices",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        480,
        400
      ]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://api.github.com/repos/microsoft/vscode/releases/latest",
        "options": {}
      },
      "id": "fetch-tech-updates",
      "name": "Fetch Tech Updates",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        480,
        600
      ]
    },
    {
      "parameters": {
        "jsCode": "// Aggregate and format external API data\nconst weather = $node[\"Fetch Weather Data\"].json;\nconst crypto = $node[\"Fetch Crypto Prices\"].json;\nconst techUpdate = $node[\"Fetch Tech Updates\"].json;\n\n// Process weather data\nconst weatherInfo = {\n  location: weather.name || 'Unknown',\n  temperature: Math.round(weather.main?.temp || 0),\n  feelsLike: Math.round(weather.main?.feels_like || 0),\n  humidity: weather.main?.humidity || 0,\n  description: weather.weather?.[0]?.description || 'Unknown',\n  icon: weather.weather?.[0]?.icon || '01d',\n  windSpeed: Math.round((weather.wind?.speed || 0) * 3.6), // Convert m/s to km/h\n  pressure: weather.main?.pressure || 0,\n  visibility: Math.round((weather.visibility || 0) / 1000) // Convert to km\n};\n\n// Process crypto data\nconst cryptoInfo = {\n  bitcoin: {\n    price: crypto.bitcoin?.usd || 0,\n    change24h: Math.round((crypto.bitcoin?.usd_24h_change || 0) * 100) / 100\n  },\n  ethereum: {\n    price: crypto.ethereum?.usd || 0,\n    change24h: Math.round((crypto.ethereum?.usd_24h_change || 0) * 100) / 100\n  }\n};\n\n// Process tech updates\nconst techInfo = {\n  project: 'VS Code',\n  latestVersion: techUpdate.tag_name || 'Unknown',\n  releaseDate: techUpdate.published_at ? new Date(techUpdate.published_at).toLocaleDateString() : 'Unknown',\n  releaseNotes: techUpdate.body ? techUpdate.body.substring(0, 300) + '...' : 'No release notes available',\n  downloadUrl: techUpdate.html_url || ''\n};\n\n// Calculate market sentiment\nlet marketSentiment = 'neutral';\nconst btcChange = cryptoInfo.bitcoin.change24h;\nconst ethChange = cryptoInfo.ethereum.change24h;\n\nif (btcChange > 5 && ethChange > 5) {\n  marketSentiment = 'very positive';\n} else if (btcChange > 2 && ethChange > 2) {\n  marketSentiment = 'positive';\n} else if (btcChange < -5 && ethChange < -5) {\n  marketSentiment = 'very negative';\n} else if (btcChange < -2 && ethChange < -2) {\n  marketSentiment = 'negative';\n}\n\n// Weather advisory\nlet weatherAdvisory = 'normal';\nif (weatherInfo.temperature < -10) {\n  weatherAdvisory = 'very cold';\n} else if (weatherInfo.temperature < 0) {\n  weatherAdvisory = 'cold';\n} else if (weatherInfo.temperature > 35) {\n  weatherAdvisory = 'very hot';\n} else if (weatherInfo.temperature > 30) {\n  weatherAdvisory = 'hot';\n}\n\nif (weatherInfo.humidity > 80) {\n  weatherAdvisory += ', high humidity';\n}\n\nif (weatherInfo.windSpeed > 25) {\n  weatherAdvisory += ', windy';\n}\n\nreturn {\n  timestamp: new Date().toISOString(),\n  weather: weatherInfo,\n  crypto: cryptoInfo,\n  tech: techInfo,\n  insights: {\n    marketSentiment,\n    weatherAdvisory,\n    cryptoTrend: btcChange > 0 ? 'bullish' : 'bearish',\n    recommendedActions: [\n      weatherInfo.temperature < 0 ? 'Bundle up for cold weather' : null,\n      weatherInfo.temperature > 30 ? 'Stay hydrated' : null,\n      Math.abs(btcChange) > 10 ? 'High crypto volatility - monitor positions' : null,\n      techInfo.latestVersion ? `New ${techInfo.project} release available` : null\n    ].filter(Boolean)\n  },\n  summary: `Weather: ${weatherInfo.temperature}Â°C, ${weatherInfo.description}. ` +\n          `Crypto: BTC ${btcChange >= 0 ? '+' : ''}${btcChange}%, ETH ${ethChange >= 0 ? '+' : ''}${ethChange}%. ` +\n          `${techInfo.project} ${techInfo.latestVersion} released.`\n};"
      },
      "id": "process-external-data",
      "name": "Process External Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        700,
        400
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "external-data-request",
        "options": {}
      },
      "id": "external-data-webhook",
      "name": "External Data Request Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        260,
        600
      ],
      "webhookId": "external-data-request-webhook"
    },
    {
      "parameters": {
        "jsCode": "// Parse external data request\nconst request = $json.body;\n\nif (!request.service) {\n  throw new Error('Service parameter is required');\n}\n\nconst supportedServices = {\n  weather: {\n    name: 'Weather',\n    endpoint: 'https://api.openweathermap.org/data/2.5/weather',\n    apiKey: process.env.WEATHER_API_KEY,\n    params: {\n      q: request.location || 'New York,US',\n      units: request.units || 'metric',\n      appid: process.env.WEATHER_API_KEY\n    }\n  },\n  crypto: {\n    name: 'Cryptocurrency',\n    endpoint: 'https://api.coingecko.com/api/v3/simple/price',\n    params: {\n      ids: request.coins || 'bitcoin,ethereum',\n      vs_currencies: request.currency || 'usd',\n      include_24hr_change: 'true',\n      include_market_cap: 'true'\n    }\n  },\n  news: {\n    name: 'News',\n    endpoint: 'https://newsapi.org/v2/top-headlines',\n    apiKey: process.env.NEWS_API_KEY,\n    params: {\n      country: request.country || 'us',\n      category: request.category || 'technology',\n      pageSize: request.limit || 10,\n      apiKey: process.env.NEWS_API_KEY\n    }\n  },\n  github: {\n    name: 'GitHub',\n    endpoint: `https://api.github.com/repos/${request.repo || 'microsoft/vscode'}/releases/latest`,\n    headers: {\n      'Authorization': `token ${process.env.GITHUB_TOKEN}`,\n      'Accept': 'application/vnd.github.v3+json'\n    }\n  }\n};\n\nconst serviceConfig = supportedServices[request.service.toLowerCase()];\n\nif (!serviceConfig) {\n  throw new Error(`Unsupported service: ${request.service}. Supported: ${Object.keys(supportedServices).join(', ')}`);\n}\n\n// Build API request URL\nlet apiUrl = serviceConfig.endpoint;\nif (serviceConfig.params) {\n  const urlParams = new URLSearchParams(serviceConfig.params);\n  apiUrl += '?' + urlParams.toString();\n}\n\nreturn {\n  service: request.service,\n  serviceName: serviceConfig.name,\n  apiUrl,\n  headers: serviceConfig.headers || {},\n  requestId: `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n  timestamp: new Date().toISOString(),\n  originalRequest: request\n};"
      },
      "id": "parse-external-request",
      "name": "Parse External Data Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        700
      ]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $json.apiUrl }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": "={{ Object.entries($json.headers).map(([key, value]) => ({ name: key, value })) }}"
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "fetch-external-api",
      "name": "Fetch External API Data",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        700,
        700
      ]
    },
    {
      "parameters": {
        "jsCode": "// Format external API response\nconst requestInfo = $node[\"Parse External Data Request\"].json;\nconst apiResponse = $json;\n\nlet formattedData = {};\n\n// Format response based on service type\nswitch (requestInfo.service.toLowerCase()) {\n  case 'weather':\n    formattedData = {\n      location: apiResponse.name,\n      temperature: Math.round(apiResponse.main?.temp || 0),\n      feelsLike: Math.round(apiResponse.main?.feels_like || 0),\n      description: apiResponse.weather?.[0]?.description,\n      humidity: apiResponse.main?.humidity,\n      windSpeed: Math.round((apiResponse.wind?.speed || 0) * 3.6),\n      pressure: apiResponse.main?.pressure\n    };\n    break;\n    \n  case 'crypto':\n    formattedData = {};\n    Object.keys(apiResponse).forEach(coin => {\n      formattedData[coin] = {\n        price: apiResponse[coin].usd,\n        change24h: Math.round((apiResponse[coin].usd_24h_change || 0) * 100) / 100,\n        marketCap: apiResponse[coin].usd_market_cap\n      };\n    });\n    break;\n    \n  case 'news':\n    formattedData = {\n      totalResults: apiResponse.totalResults,\n      articles: (apiResponse.articles || []).slice(0, 5).map(article => ({\n        title: article.title,\n        description: article.description,\n        source: article.source.name,\n        publishedAt: article.publishedAt,\n        url: article.url\n      }))\n    };\n    break;\n    \n  case 'github':\n    formattedData = {\n      version: apiResponse.tag_name,\n      releaseDate: apiResponse.published_at,\n      releaseName: apiResponse.name,\n      releaseNotes: apiResponse.body?.substring(0, 500) + '...',\n      downloadUrl: apiResponse.html_url,\n      author: apiResponse.author?.login\n    };\n    break;\n    \n  default:\n    formattedData = apiResponse;\n}\n\nreturn {\n  requestId: requestInfo.requestId,\n  service: requestInfo.serviceName,\n  timestamp: new Date().toISOString(),\n  data: formattedData,\n  success: true,\n  processingTime: Date.now() - new Date(requestInfo.timestamp).getTime()\n};"
      },
      "id": "format-external-response",
      "name": "Format External Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        920,
        700
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json, null, 2) }}"
      },
      "id": "respond-with-data",
      "name": "Respond with Formatted Data",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1140,
        700
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.CLAUDE_PROXY_URL }}/v1/messages",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpBearerAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": []
        },
        "jsonBody": "={{ JSON.stringify({\n  model: \"claude-3-haiku-20240307\",\n  max_tokens: 800,\n  messages: [{\n    role: \"user\",\n    content: `Create a morning briefing summary based on this external data:\n\n**Weather Data:**\nLocation: ${$json.weather.location}\nTemperature: ${$json.weather.temperature}Â°C (feels like ${$json.weather.feelsLike}Â°C)\nConditions: ${$json.weather.description}\nHumidity: ${$json.weather.humidity}%\nWind: ${$json.weather.windSpeed} km/h\n\n**Cryptocurrency Market:**\nBitcoin: $${$json.crypto.bitcoin.price.toLocaleString()} (${$json.crypto.bitcoin.change24h >= 0 ? '+' : ''}${$json.crypto.bitcoin.change24h}%)\nEthereum: $${$json.crypto.ethereum.price.toLocaleString()} (${$json.crypto.ethereum.change24h >= 0 ? '+' : ''}${$json.crypto.ethereum.change24h}%)\n\n**Tech Updates:**\n${$json.tech.project} ${$json.tech.latestVersion} released on ${$json.tech.releaseDate}\n\n**Current Analysis:**\nMarket Sentiment: ${$json.insights.marketSentiment}\nWeather Advisory: ${$json.insights.weatherAdvisory}\nCrypto Trend: ${$json.insights.cryptoTrend}\n\nCreate a concise morning briefing (2-3 paragraphs) that:\n1. Highlights the key information\n2. Provides context and insights\n3. Suggests any actionable items\n4. Maintains a professional yet engaging tone\n\nFormat it as a morning briefing suitable for a team or personal daily summary.`\n  }]\n}) }}"
      },
      "id": "generate-ai-briefing",
      "name": "Generate AI Briefing",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        920,
        300
      ],
      "credentials": {
        "httpBearerAuth": {
          "id": "claude-api-creds",
          "name": "Claude API Credentials"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SLACK_WEBHOOK_URL }}",
        "sendBody": true,
        "bodyParameters": {
          "parameters": []
        },
        "jsonBody": "={{ JSON.stringify({\n  text: \"ðŸŒ… Morning Data Briefing\",\n  blocks: [\n    {\n      type: 'header',\n      text: {\n        type: 'plain_text',\n        text: 'ðŸŒ… Morning Data Briefing'\n      }\n    },\n    {\n      type: 'section',\n      text: {\n        type: 'mrkdwn',\n        text: $node[\"Generate AI Briefing\"].json.content[0].text\n      }\n    },\n    {\n      type: 'divider'\n    },\n    {\n      type: 'section',\n      fields: [\n        {\n          type: 'mrkdwn',\n          text: `*ðŸŒ¡ï¸ Weather*\\n${$node[\"Process External Data\"].json.weather.location}\\n${$node[\"Process External Data\"].json.weather.temperature}Â°C, ${$node[\"Process External Data\"].json.weather.description}`\n        },\n        {\n          type: 'mrkdwn',\n          text: `*â‚¿ Crypto*\\nBTC: $${$node[\"Process External Data\"].json.crypto.bitcoin.price.toLocaleString()} (${$node[\"Process External Data\"].json.crypto.bitcoin.change24h >= 0 ? '+' : ''}${$node[\"Process External Data\"].json.crypto.bitcoin.change24h}%)\\nETH: $${$node[\"Process External Data\"].json.crypto.ethereum.price.toLocaleString()} (${$node[\"Process External Data\"].json.crypto.ethereum.change24h >= 0 ? '+' : ''}${$node[\"Process External Data\"].json.crypto.ethereum.change24h}%)`\n        }\n      ]\n    },\n    {\n      type: 'section',\n      text: {\n        type: 'mrkdwn',\n        text: `*ðŸš€ Tech Update*\\n${$node[\"Process External Data\"].json.tech.project} ${$node[\"Process External Data\"].json.tech.latestVersion} was released on ${$node[\"Process External Data\"].json.tech.releaseDate}`\n      }\n    },\n    {\n      type: 'context',\n      elements: [\n        {\n          type: 'mrkdwn',\n          text: `Generated: ${new Date($node[\"Process External Data\"].json.timestamp).toLocaleString()}`\n        }\n      ]\n    }\n  ]\n}) }}"
      },
      "id": "send-morning-briefing",
      "name": "Send Morning Briefing",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1140,
        300
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO external_api_requests (request_id, service, timestamp, success, processing_time_ms, data_summary) VALUES ('{{ $json.requestId }}', '{{ $json.service }}', '{{ $json.timestamp }}', {{ $json.success }}, {{ $json.processingTime }}, '{{ JSON.stringify($json.data).substring(0, 1000) }}');",
        "additionalFields": {}
      },
      "id": "log-external-request",
      "name": "Log External API Request",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1360,
        700
      ],
      "credentials": {
        "postgres": {
          "id": "postgres-creds",
          "name": "PostgreSQL Credentials"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.error }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "external-api-error",
      "name": "External API Error?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        480,
        900
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({\n  success: false,\n  error: $json.error || 'External API request failed',\n  service: $json.service || 'unknown',\n  timestamp: new Date().toISOString(),\n  requestId: $json.requestId || 'unknown'\n}, null, 2) }}"
      },
      "id": "respond-with-error",
      "name": "Respond with Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        700,
        1000
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Morning Data Fetch": {
      "main": [
        [
          {
            "node": "Fetch Weather Data",
            "type": "main",
            "index": 0
          },
          {
            "node": "Fetch Crypto Prices",
            "type": "main",
            "index": 0
          },
          {
            "node": "Fetch Tech Updates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Weather Data": {
      "main": [
        [
          {
            "node": "Process External Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Crypto Prices": {
      "main": [
        [
          {
            "node": "Process External Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Tech Updates": {
      "main": [
        [
          {
            "node": "Process External Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process External Data": {
      "main": [
        [
          {
            "node": "Generate AI Briefing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "External Data Request Webhook": {
      "main": [
        [
          {
            "node": "Parse External Data Request",
            "type": "main",
            "index": 0
          },
          {
            "node": "External API Error?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse External Data Request": {
      "main": [
        [
          {
            "node": "Fetch External API Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch External API Data": {
      "main": [
        [
          {
            "node": "Format External Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format External Response": {
      "main": [
        [
          {
            "node": "Respond with Formatted Data",
            "type": "main",
            "index": 0
          },
          {
            "node": "Log External API Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate AI Briefing": {
      "main": [
        [
          {
            "node": "Send Morning Briefing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "External API Error?": {
      "main": [
        [
          {
            "node": "Respond with Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "external-api-integrations-workflow",
  "tags": [
    {
      "createdAt": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-01T00:00:00.000Z",
      "id": "external-apis",
      "name": "External APIs"
    },
    {
      "createdAt": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-01T00:00:00.000Z",
      "id": "integrations",
      "name": "Integrations"
    }
  ]
}